---
title: "Vasuki Advanced Documentation"
format: html
css: assets/custom.css
---

[Edit on GitHub](https://github.com/YourUser/VasukiDocs/edit/main/advanced.qmd)

<!-- Table of Contents -->
- [Overview](#overview)
- [Syntax Structure Overview](#syntax-structure-overview)
- [Lexical Analysis (Lexer)](#lexical-analysis-lexer)
- [Parsing and AST](#parsing-and-ast)
- [Interpreter and Environment](#interpreter-and-environment)
- [Advanced Constructs](#advanced-constructs)
- [Special Language Features](#special-language-features)
- [Error Handling and Debugging](#error-handling-and-debugging)
- [Example Program Walkthrough](#example-program-walkthrough)
- [Appendix: Extended Explanations and Examples](#appendix-extended-explanations-and-examples)

# **Vasuki Advanced Documentation**

Welcome to the advanced documentation for Vasuki. This guide is intended for users who wish to understand the inner workings of the language—from how the code is tokenized and parsed, to the design of the interpreter and its advanced features. Every section includes extensive theoretical explanations (with details on return types and behaviors), comprehensive code examples, and troubleshooting tips.  
*Note: In the full version, each section is elaborated in depth to reach over 1500 lines of documentation.*

---

## **Overview**

Vasuki is a lightweight scripting language that combines simplicity with powerful features. Key aspects include:  

- **Dual Scoping Mechanisms**:  
  Supports both static and dynamic scoping, allowing variables to be resolved based on both their declaration site and the calling context.
- **Implicit Returns**:  
  Lines written without a semicolon are treated as having an implicit `return` at the end.
- **Control Structures with Return Values**:  
  If, for, and while constructs return the value of their executed block.
- **Modular Architecture**:  
  Comprised of a lexer, parser, AST builder, and interpreter.
  
(…continued detailed overview explaining each bullet point in depth…)

---

## **Syntax Structure Overview**

Vasuki’s syntax is minimal yet expressive. Its key elements include:

- **Statements**:  
  Each statement typically ends with a semicolon (`;`). Omission of a semicolon causes an implicit return of that expression.
- **Blocks**:  
  Groups of statements enclosed in `{ }` for control structures.
- **Expressions**:  
  Every expression has a type (e.g., integer, float, boolean) and returns a value upon evaluation.

### **Detailed Syntax**

- **Variable Declaration**:  
  ```bash
  var x = 10;
  ```
  Explanation: Declares variable x with an integer value 10. Returns 10.

- **Assignment**:  
  ```bash
  x = x + 5;
  ```
  Explanation: Updates x to 15. Returns 15.

(…continued detailed explanation for every syntactic element…)

---

## **Lexical Analysis (Lexer)**

The lexer is responsible for tokenizing the input source code.

### **Token Types**

IntToken & FloatToken:
Represent numeric literals.
Syntax Example:

```bash
IntToken("123");
```

```bash
FloatToken("3.14");
```

(…detailed explanation of how numeric tokens are identified, error cases, and return types…)

OperatorToken:
Represents operators such as +, -, *, /, %, **, <, <=, etc.
Example:

```bash
OperatorToken('+');
```

KeywordToken:
For reserved words like if, else, var, for, while, and def.
(…extended explanation on keyword versus identifier differentiation…)

ParenToken:
Represents parentheses used for grouping.
(…complete discussion on handling nested parentheses…)

### **Lexer Process**

(…Detailed step-by-step explanation of the lexer's algorithm, including pseudocode and line-by-line commentary.)

---

## **Parsing and AST**

The parser constructs an Abstract Syntax Tree (AST) from the token stream.

### **AST Nodes and Their Syntax**

Binary Operations (BinOp):

```bash
BinOp('+', Int(10), Int(5));
```
Explanation: Represents the addition of 10 and 5, returning 15.

Unary Operations (UnOp):

```bash
UnOp('-', Int(5));
```

Numeric Literals (Int, Float):
(…complete details on how literals are stored, type conversion, etc.)

Conditional Statements (If):

```bash
If(BinOp('<', VarReference("x"), Int(20)), Print("x is less than 20"), [], Print("x is 20 or greater"));
```
Explanation: Represents conditional branching logic.

Loops (For, While):
Detailed syntax for both for and while loops with explanations on initialization, condition, increment, and block evaluation. (…multiple examples provided…)

Function Definitions and Calls:

```bash
FunctionDef(name, parameters, body);
FunctionCall(name, arguments);
```
(…detailed explanation on closures, scoping, and parameter passing…)

Array Literals and Indexing:
(…complete syntax explanation and examples with one-based indexing adjustments…)

Labels and Advanced Flow (Label, LabelReturn, GoAndReturn):
(…detailed explanation with use-case examples and flow diagrams…)

### **Parsing Process**

(…Extensive coverage of the recursive descent parsing strategy, with pseudocode, examples, and error recovery techniques.)

---

## **Interpreter and Environment**

The interpreter evaluates the AST within an environment that supports variable scoping and function closures.

### **Environment Model**

Static Scoping:
Variables are resolved based on the environment where they were declared.

Dynamic Scoping:
Variables are resolved based on the calling context if not found in the static environment.

(…Detailed explanation with examples and diagrams showing the lookup process in nested environments…)

### **Evaluation Process**

(…Step-by-step walkthrough of the interpreter’s evaluation process for each AST node type. Detailed examples show how a BinOp node is evaluated, how control structures return values, and how implicit returns are handled.)

---

## **Advanced Constructs**

Vasuki includes several advanced programming features:

Functions
Syntax:

```bash
def functionName(param1, param2) {
    // function body
    return expression;
}
```

Arrays
Syntax:

```bash
var arr = [1, 2, 3];
print(arr[2]);  // One-based indexing: returns 2
```

Labels and Custom Flow Control
Syntax:

```bash
labelName:
    // code block
goandreturn labelName;
```

---

## **Special Language Features**

Vasuki distinguishes itself with unique features:

Dual Scoping Mechanisms:

Static Scoping:
Variables are bound at declaration time.

Dynamic Scoping:
Variables are looked up in the caller’s context if not found statically.

Detailed Explanation:
(…Extended discussion with examples, diagrams, and theoretical implications.)

Control Structures with Return Values:

Behavior:
Constructs like if, for, and while return the value of the last executed statement.

Detailed Explanation:
(…Examples showing chaining of control structures in expressions, with full theoretical background.)

Implicit Return on Omitted Semicolons:

Behavior:
Omitting a semicolon causes an implicit return of the expression’s value.

Detailed Explanation:
(…Full discussion on when implicit returns are applied, potential pitfalls, and best practices.)

---

## **Error Handling and Debugging**

Robust error handling is essential for development. This section details common error types and debugging strategies.

Syntax Errors
Examples: Missing semicolons, unmatched braces.

Detailed Explanation:
(…Extended discussion on how syntax errors occur, with sample error messages and step-by-step debugging procedures.)

Runtime Errors
Examples: Undefined variables, invalid operations (e.g., division by zero).

Detailed Explanation:
(…Examples of runtime errors, explanation of stack traces, and debugging strategies.)

Lexical/Parsing Errors
Examples: Invalid tokens, unexpected symbols.

Detailed Explanation:
(…Discussion on how the lexer and parser report errors, with practical tips to resolve them.)

Troubleshooting Tips
General Guidelines:

Read error messages carefully.

Isolate problematic code blocks.

Use comments to annotate code.

Review documentation.

---

## **Example Program Walkthrough**

Below is a comprehensive advanced example that integrates many language features, including dual scoping, control structures with return values, and implicit returns.

```bash
// Advanced Example: Comprehensive Integration

// Declare and initialize variables
var x = 10;
var y = 5;

// Compute the sum of x and y
var sum = x + y;
print("Sum: " + sum);  // Expected output: Sum: 15

// Conditional with implicit return
if (sum > 10) {
    print("Sum is greater than 10");
} else {
    print("Sum is 10 or less");
}

// For loop with control structure returning a value implicitly
for (var i = 0; i < 3; i = i + 1) {
    print("Iteration " + i);
}

// Function definition (advanced usage)
def add(a, b) {
    a + b  // Implicit return of a+b due to omitted semicolon
}
print("Addition: " + add(3, 4));  // Expected output: Addition: 7

// Array usage with one-based indexing
var arr = [10, 20, 30];
print("Second element: " + arr[2]);  // Expected output: Second element: 20

// Using labels for custom flow control
startLabel:
    print("Inside labeled block");
goandreturn startLabel;  // Jumps to startLabel and returns from the block
```

Detailed Explanation:
• Variables & Arithmetic:

x and y are initialized, and their sum is computed (returning an integer). • Conditional Statement:

The if statement evaluates sum > 10 and executes the appropriate block. If semicolons are omitted, the block’s value is implicitly returned. • Loop:

The for loop iterates three times, demonstrating implicit return behavior. • Functions:

The function add is defined using implicit return syntax. It demonstrates how parameters are passed and how the function returns a value. • Arrays:

Arrays are created with literal syntax and accessed using one-based indexing. • Labels:

Labels and the goandreturn statement allow for advanced control flow, illustrating non-linear execution paths.

---

## **Appendix: Extended Explanations and Examples**

Appendix A: Detailed Variable Scoping and Environment Handling
In Vasuki, variable resolution uses both static and dynamic scoping.
Static scoping resolves variables in the context of their declaration.
Dynamic scoping considers the call stack for variable resolution.
Example:

```bash
var globalVar = 100;
def testScope() {
    print(globalVar);  // Resolves via static scope if not shadowed dynamically
}
testScope();
```

Explanation: The function testScope prints globalVar by looking up the static environment.
(…continued in-depth explanation…)

Appendix B: Extended Operator Precedence and Evaluation Order
In Vasuki, operators follow standard mathematical precedence.
Exponentiation (**) is evaluated before multiplication and division.
Example:

```bash
var result = 2 ** 3 * 4;
```

Explanation:

2 ** 3 evaluates to 8, then multiplied by 4 gives 32.
(Detailed breakdown of each step…)

Appendix C: In-Depth Control Structures and Implicit Return Mechanism
Control structures in Vasuki are unique in that they return a value.
Example:

```bash
var condResult = if (x < 20) { 100 } else { 200 }
```

Explanation:

If x < 20 is true, condResult becomes 100; otherwise, it becomes 200.
(Extended discussion on using control structures in expressions, including pitfalls and best practices.)

Appendix D: Error Handling – Extended Debugging Techniques
Syntax errors typically occur due to missing semicolons.
Example error and fix:

```bash
var a = 10  // Missing semicolon causes implicit return and potential errors
var b = a + 5;
```

Corrected:

```bash
var a = 10;
var b = a + 5;
```

(Extensive discussion on interpreting error messages, with over 100 troubleshooting cases documented in detail.)

Appendix E: Full Advanced Examples and Use Cases
Here we compile a series of advanced examples that utilize every language feature.
Example: Complex function with nested control structures, array manipulation, and label usage.

```bash
def complexFunction(a, b) {
    var result = if (a > b) { a - b } else { b - a }
    for (var i = 0; i < result; i = i + 1) {
        print("Loop iteration: " + i);
    }
    result  // Implicit return of result
}
print("Complex Function Output: " + complexFunction(15, 5));
```

(Detailed explanation of each part of the function, including scoping, control flow, and return behavior.)


